@page "/testclientwebsocket"
@using System.Net.WebSockets
@using System.Text
@using System.Threading
@implements IDisposable

@inject IHttpClientFactory HttpClientFactory
@inject IWebAssemblyHostEnvironment Env

@attribute [Authorize]

<h1>Echo test</h1>
<h3>State: @webSocket.State</h3>

<div>BaseAddress: @Env.BaseAddress</div>
<div>
    Uri: <input type="text" @bind="@uri" />
</div>
<div>
    Message: <input type="text" @bind="@message" />
</div> 

<button class="btn btn-info" @onclick="ConnectAsync">Connect</button>
<button class="btn btn-primary" @onclick="SendMessageAsync">SendMessage</button>
<button class="btn btn-secondary" @onclick="CloseAsync">Close</button>

@if (webSocket.State == WebSocketState.Open)
{
    <pre>@log</pre>
}

@code {
    //https://gist.github.com/SteveSandersonMS/5aaff6b010b0785075b0a08cc1e40e01
    CancellationTokenSource disposalTokenSource = new CancellationTokenSource();
    ClientWebSocket webSocket = new ClientWebSocket();
    string message = "Hello, websocket!";
    string? uri;
    //wss://ws.postman-echo.com/raw
    //https://guppy-api-staging.casa-terraneo.workers.dev/
    //wss://guppy-api-staging.casa-terraneo.workers.dev/ws
    string log = "";

    protected override void OnInitialized()
    {
        using var http = HttpClientFactory.CreateClient("api");
        var uriBuilder = new UriBuilder(http.BaseAddress)
        {
            Scheme = "wss",
            Port = -1
        };
        uri = uriBuilder.Uri.ToString().Replace("/api", "/ws").TrimEnd('/');
    }

    async Task ConnectAsync()
    {
        await webSocket.ConnectAsync(new Uri(uri), disposalTokenSource.Token);
        _ = ReceiveLoop();
    }

    async Task SendMessageAsync()
    {
        log += $"Sending: {message}\n";
        var dataToSend = new ArraySegment<byte>(Encoding.UTF8.GetBytes(message));
        await webSocket.SendAsync(dataToSend, WebSocketMessageType.Text, true, disposalTokenSource.Token);
    }

    async Task ReceiveLoop()
    {
        var buffer = new ArraySegment<byte>(new byte[1024]);
        while (!disposalTokenSource.IsCancellationRequested)
        {
            // Note that the received block might only be part of a larger message. If this applies in your scenario,
            // check the received.EndOfMessage and consider buffering the blocks until that property is true.
            // Or use a higher-level library such as SignalR.
            var received = await webSocket.ReceiveAsync(buffer, disposalTokenSource.Token);
            var receivedAsText = Encoding.UTF8.GetString(buffer.Array, 0, received.Count);
            log += $"Received: {receivedAsText}\n";
            StateHasChanged();
        }
    }

    async Task CloseAsync()
    {
        await webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Bye", CancellationToken.None);        
    }

    public void Dispose()
    {
        disposalTokenSource.Cancel();
        _ = CloseAsync();
    }
}