@page "/tris"
@attribute [Authorize]

@implements IAsyncDisposable

@inject IHttpClientFactory HttpClientFactory
@inject IWebAssemblyHostEnvironment Env

@using System.Linq
@using System.Net.WebSockets
@using System.Text
@using System.Security.Claims

<PageTitle>Tris</PageTitle>

<h3 class="mb-4">Tris</h3>

<button class="btn btn-primary mt-2" 
    disabled="@(_webSocket.State == WebSocketState.Open)"
    @onclick="ConnectAsync">Inizia Partita
</button>

<div class="container">
    <div class="row justify-content-center">
        <div class="col-auto">
            <div class="d-grid gap-2">
                @for (int row = 0; row < 3; row++)
                {
                    <div class="btn-group">
                        @for (int col = 0; col < 3; col++)
                        {
                            int idx = row * 3 + col;
                            <button class="btn btn-outline-primary btn-lg"
                                    style="width: 70px; height: 70px; font-size:2rem;"
                                    disabled="@(!string.IsNullOrEmpty(board[idx]) 
                                                || !string.IsNullOrEmpty(winner) 
                                                || !IsMyTurn())"
                                    @onclick="async () => await MakeMoveAsync(idx)">
                                @board[idx]
                            </button>
                        }
                    </div>
                }
            </div>
        </div>
    </div>
    <div class="row mt-4 justify-content-center">
        <div class="col-auto">
            @if (!string.IsNullOrEmpty(winner))
            {
                <div class="alert alert-success">
                    @winner
                </div>
            }
            else if (board.All(cell => !string.IsNullOrEmpty(cell)))
            {
                <div class="alert alert-warning">
                    Pareggio!
                </div>
            }
            <button class="btn btn-secondary mt-2" @onclick="Reset">Reset</button>
        </div>
    </div>
</div>

@code {    
    [CascadingParameter]
    private Task<AuthenticationState> AuthenticationState { get; set; }    
    string[] board = new string[9];    
    string currentPlayer = "";       
    string winner;
    string _uri;
    private ClientWebSocket _webSocket;
    private CancellationTokenSource _cts;    

    private async Task MakeMoveAsync(int idx)
    {
        if (!string.IsNullOrEmpty(board[idx]) 
            || !string.IsNullOrEmpty(winner)
            || _webSocket.State != WebSocketState.Open)
            return;        
        
        if(currentPlayer == "" && board.Count(c => c == "X") == 0)
            currentPlayer = "X";

        if(currentPlayer == "" && board.Count(c => c == "O") == 0)
            currentPlayer = "O";

        board[idx] = currentPlayer;

        await SendMessageAsync();   // Invia il messaggio al server
        
        if (CheckWin(currentPlayer))
        {
            winner = $"Ha vinto {currentPlayer}!";
        }
    }

    private bool IsMyTurn()
    {
        int countX = board.Count(c => c == "X");
        int countO = board.Count(c => c == "O");

        if(_webSocket.State != WebSocketState.Open)
            return false;
        if (currentPlayer == "")                    
            return true;        
        if (currentPlayer == "X")
            return countX == countO; // X gioca se ha fatto lo stesso numero di mosse di O (inizia sempre)
        if (currentPlayer == "O")
            return countX > countO;// O gioca se ha fatto una mossa in meno di X

        throw new ArgumentException("Player deve essere 'X' o 'O'");        
    }

    private bool CheckWin(string player)
    {
        int[,] wins = new int[,] {
            {0,1,2}, {3,4,5}, {6,7,8}, // righe
            {0,3,6}, {1,4,7}, {2,5,8}, // colonne
            {0,4,8}, {2,4,6}           // diagonali
        };
        for (int i = 0; i < wins.GetLength(0); i++)
        {
            if (board[wins[i,0]] == player && board[wins[i,1]] == player && board[wins[i,2]] == player)
                return true;
        }
        return false;
    }

    private async Task Reset()
    {
        board = new string[9];
        winner = null;
        currentPlayer = "";
        await SendMessageAsync();   // Invia il messaggio al server
    }

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
        var state = await AuthenticationState;
        var username = state?.User?.Identity?.Name;
        if (string.IsNullOrEmpty(username))
        {
            throw new InvalidOperationException("Username non trovato.");
        }
        
        using var http = HttpClientFactory.CreateClient("api");
        var uriBuilder = new UriBuilder(http.BaseAddress)
        {
            Scheme = "wss",
            Port = -1,
            Query = $"username={Uri.EscapeDataString(username)}"
        };
        _uri = uriBuilder.Uri.ToString().Replace("/api", "/tris").TrimEnd('/');

        _webSocket = new ClientWebSocket();
        _cts = new CancellationTokenSource();
    }   

    private async Task ConnectAsync()
    {
        if (_webSocket.State == WebSocketState.Closed 
            || _webSocket.State == WebSocketState.Aborted 
            || _webSocket.State == WebSocketState.None)
        {
            _webSocket = new ClientWebSocket();
            _cts = new CancellationTokenSource();
        }        
        if (_webSocket.State != WebSocketState.Open)
        {
            await _webSocket.ConnectAsync(new Uri(_uri), _cts.Token);
            _ = ReceiveLoopAsync();
        }
    }

    private async Task ReceiveLoopAsync()
    {        
        var buffer = new byte[1024];
        try
        {
            while (_webSocket.State == WebSocketState.Open && !_cts.IsCancellationRequested)
            {                
                var result = await _webSocket.ReceiveAsync(new ArraySegment<byte>(buffer), _cts.Token);             
                var text = Encoding.UTF8.GetString(buffer, 0, result.Count);   
                
                if(string.IsNullOrWhiteSpace(text)) 
                    continue; 

                board = text.Split('|').ToArray();
                StateHasChanged();
            }
        }
        catch (OperationCanceledException)
        {
            // Chiusura attesa, non loggiamo
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Errore ReceiveLoop: {ex.Message}");
        }
    }

    private async Task SendMessageAsync()
    {       
        if (_webSocket.State == WebSocketState.Open)
        {
            var _message = string.Join("|", board);
            var bytes = Encoding.UTF8.GetBytes(_message);
            await _webSocket.SendAsync(new ArraySegment<byte>(bytes), WebSocketMessageType.Text, true, _cts.Token);            
        }
    }

    private async Task CloseAsync()
    {       
        if (_webSocket is not null && _webSocket.State == WebSocketState.Open)
        {            
            await _webSocket.CloseAsync(WebSocketCloseStatus.NormalClosure, "Chiusura client", CancellationToken.None);     
            _cts.Cancel();  // Fa terminare ReceiveLoop
        }       
    }

    public async ValueTask DisposeAsync()
    {       
        await CloseAsync();             
        _webSocket?.Dispose();         
        _cts?.Dispose();     
    }         
}
